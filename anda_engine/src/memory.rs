use anda_cognitive_nexus::{CognitiveNexus, ConceptPK};
use anda_core::{
    BoxError, FunctionDefinition, Resource, ResourceRef, StateFeatures, Tool, ToolOutput, Xid,
    gen_schema_for,
};
use anda_db::{
    collection::{Collection, CollectionConfig},
    database::AndaDB,
    error::DBError,
    index::BTree,
    query::{Filter, Query, RangeQuery, Search},
};
use anda_db_schema::{AndaDBSchema, FieldEntry, FieldType, Fv, Json, Schema, SchemaError};
use anda_db_tfs::jieba_tokenizer;
use anda_kip::{
    CommandType, DescribeTarget, KIP_FUNCTION_DEFINITION, META_SYSTEM_NAME, MetaCommand,
    PERSON_TYPE, Request, Response,
};
use candid::Principal;
use ic_auth_types::ByteBufB64;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::sync::{Arc, LazyLock};

use crate::{context::BaseCtx, extension::fetch::FetchWebResourcesTool, unix_ms};

pub static FUNCTION_DEFINITION: LazyLock<FunctionDefinition> =
    LazyLock::new(|| serde_json::from_value(KIP_FUNCTION_DEFINITION.clone()).unwrap());

#[derive(Debug, Clone, Deserialize, Serialize, AndaDBSchema)]
pub struct Chat {
    /// The unique identifier for this resource in the Anda DB collection "chat".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Option<Bytes>"]
    pub thread: Option<Xid>,

    pub messages: Vec<Json>,

    /// The request resources used by the agent to process the chat.
    pub resources: Vec<Resource>,

    /// A collection of artifacts generated by the agent during the execution of the task.
    pub artifacts: Vec<Resource>,

    /// The period when the chat was created, in hours (timestamp / 3600 / 1000).
    /// It is used to index the chat for faster retrieval by time.
    pub period: u64,

    /// The timestamp when the chat was created, in milliseconds.
    pub start_time: u64,

    /// The timestamp when the chat was ended, in milliseconds.
    pub end_time: u64,
}

#[derive(Debug, Serialize)]
pub struct ChatRef<'a> {
    /// The unique identifier for this resource in the Anda DB collection "chat".
    pub _id: u64,

    pub user: &'a Principal,

    pub thread: Option<&'a Xid>,

    pub messages: &'a [Json],

    /// The request resources used by the agent to process the chat.
    pub resources: &'a [Resource],

    /// A collection of artifacts generated by the agent during the execution of the task.
    pub artifacts: &'a [Resource],

    /// The period when the chat was created, in hours (timestamp / 3600 / 1000).
    /// It is used to index the chat for faster retrieval by time.
    pub period: u64,

    /// The timestamp when the chat was created, in milliseconds.
    pub start_time: u64,

    /// The timestamp when the chat was ended, in milliseconds.
    pub end_time: u64,
}

#[derive(Debug, Deserialize, Serialize, AndaDBSchema)]
pub struct KIPLogs {
    /// The unique identifier for this resource in the Anda DB collection "kip_logs".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Text"]
    pub command: CommandType,

    #[field_type = "Map<String, Json>"]
    pub request: anda_kip::Request,

    #[field_type = "Map<String, Json>"]
    pub response: anda_kip::Response,

    pub period: u64,

    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub struct MemoryManagement {
    nexus: Arc<CognitiveNexus>,
    chats: Arc<Collection>,
    logs: Arc<Collection>,
    resources: Arc<Collection>,
}

impl MemoryManagement {
    pub async fn connect(nexus: Arc<CognitiveNexus>, db: Arc<AndaDB>) -> Result<Self, BoxError> {
        let schema = Chat::schema()?;
        let chats = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "chats".to_string(),
                    description: "chats collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["user"]).await?;
                    collection.create_btree_index_nx(&["thread"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;
                    collection
                        .create_bm25_index_nx(&["messages", "resources", "artifacts"])
                        .await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        let schema = KIPLogs::schema()?;
        let logs = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "kip_logs".to_string(),
                    description: "KIP logs collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["command"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        let schema = Resource::schema()?;
        let resources = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "resources".to_string(),
                    description: "Resources collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["tag"]).await?;
                    collection.create_btree_index_nx(&["hash"]).await?;
                    collection.create_btree_index_nx(&["mime_type"]).await?;
                    collection
                        .create_bm25_index_nx(&["name", "description", "metadata"])
                        .await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        Ok(Self {
            nexus,
            chats,
            logs,
            resources,
        })
    }

    pub async fn describe_primer(&self) -> Result<Json, BoxError> {
        let (primer, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Primer))
            .await?;
        Ok(primer)
    }

    pub async fn describe_system(&self) -> Result<Json, BoxError> {
        let system = self
            .nexus
            .get_concept(&ConceptPK::Object {
                r#type: PERSON_TYPE.to_string(),
                name: META_SYSTEM_NAME.to_string(),
            })
            .await?;
        let (domains, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Domains))
            .await?;
        Ok(json!({
            "identity": system.to_concept_node(),
            "domains": domains,
        }))
    }

    pub async fn add_resource(&self, resource: &ResourceRef<'_>) -> Result<u64, DBError> {
        let id = self.resources.add_from(resource).await?;
        Ok(id)
    }

    pub async fn flush_resources(&self) -> Result<(), BoxError> {
        self.resources.flush(unix_ms()).await?;
        Ok(())
    }

    pub async fn get_resource(&self, id: u64) -> Result<Resource, BoxError> {
        let res = self.resources.get_as(id).await?;
        Ok(res)
    }

    pub async fn add_chat(&self, chat: &ChatRef<'_>) -> Result<u64, DBError> {
        let id = self.chats.add_from(chat).await?;
        self.chats.flush(unix_ms()).await?;
        Ok(id)
    }

    pub async fn list_chats_by_user(
        &self,
        user: &Principal,
        cursor: Option<String>,
        limit: Option<usize>,
    ) -> Result<(Vec<Chat>, Option<String>), BoxError> {
        let limit = limit.unwrap_or(10).min(100);
        let cursor = BTree::from_cursor::<u64>(&cursor)?;
        let filter = if let Some(cursor) = cursor {
            Some(Filter::And(vec![
                Box::new(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                Box::new(Filter::Field((
                    "_id".to_string(),
                    RangeQuery::Lt(Fv::U64(cursor)),
                ))),
            ]))
        } else {
            Some(Filter::Field((
                "user".to_string(),
                RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
            )))
        };

        let rt: Vec<Chat> = self
            .chats
            .search_as(Query {
                search: None,
                filter,
                limit: Some(limit),
            })
            .await?;
        let cursor = if rt.len() >= limit {
            BTree::to_cursor(&rt.last().unwrap()._id)
        } else {
            None
        };
        Ok((rt, cursor))
    }

    pub async fn search_chats(
        &self,
        user: &Principal,
        query: String,
        limit: Option<usize>,
    ) -> Result<Vec<Chat>, BoxError> {
        let rt = self
            .chats
            .search_as(Query {
                search: Some(Search {
                    text: Some(query.to_string()),
                    logical_search: true,
                    ..Default::default()
                }),
                filter: Some(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                limit,
            })
            .await?;
        Ok(rt)
    }

    pub async fn delete_expired_chats(&self, timestamp: u64) -> Result<u64, BoxError> {
        let period = timestamp / 3600 / 1000;
        let filter = Filter::Field(("period".to_string(), RangeQuery::Lt(Fv::U64(period))));
        let ids = self
            .chats
            .search_ids(Query {
                search: None,
                filter: Some(filter),
                limit: None,
            })
            .await?;
        let count = ids.len() as u64;
        for id in ids {
            if let Ok(Some(doc)) = self.chats.remove(id).await {
                if let Ok(chat) = doc.try_into::<Chat>() {
                    for resource in chat.resources {
                        if resource._id > 0 {
                            let _ = self.resources.remove(resource._id).await;
                        }
                    }

                    for artifact in chat.artifacts {
                        if artifact._id > 0 {
                            let _ = self.resources.remove(artifact._id).await;
                        }
                    }
                }
            };
        }

        let now_ms = unix_ms();
        self.chats.flush(now_ms).await?;
        self.resources.flush(now_ms).await?;
        Ok(count)
    }
}

impl Tool<BaseCtx> for Arc<MemoryManagement> {
    type Args = Request;
    type Output = Response;

    fn name(&self) -> String {
        FUNCTION_DEFINITION.name.clone()
    }

    fn description(&self) -> String {
        FUNCTION_DEFINITION.description.clone()
    }

    fn definition(&self) -> FunctionDefinition {
        FUNCTION_DEFINITION.clone()
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        request: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let timestamp = unix_ms();
        let (command, res) = request.execute(self.nexus.as_ref()).await;
        let log = KIPLogs {
            _id: 0, // This will be set by the database
            user: *ctx.caller(),
            command,
            request,
            response: res.clone(),
            period: timestamp / 3600 / 1000,
            timestamp,
        };

        // ignore errors from adding logs
        let _ = self.logs.add_from(&log).await;
        Ok(ToolOutput::new(res))
    }
}

/// Arguments for "get_resource_content" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct GetResourceArgs {
    /// The ID of the resource to get
    pub _id: u64,
}

#[derive(Debug, Clone)]
pub struct GetResourceTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl GetResourceTool {
    pub const NAME: &'static str = "get_resource_content";

    /// Creates a new GetResourceTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<GetResourceArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for GetResourceTool {
    type Args = GetResourceArgs;
    type Output = String;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "Get a resource content as text (base64-url encoded if not UTF-8) by it's ID".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let res = self.memory.get_resource(args._id).await?;
        let text = match res.blob {
            Some(blob) => match String::from_utf8(blob.0) {
                Ok(s) => s,
                Err(e) => ByteBufB64(e.into_bytes()).to_string(),
            },
            None => match res.uri {
                Some(uri) => FetchWebResourcesTool::fetch_as_text(&ctx, &uri).await?,
                None => Err(format!("Invalid resource {}, no blob or uri", args._id))?,
            },
        };

        Ok(ToolOutput::new(text))
    }
}

/// Arguments for "list_prev_conversations" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct ListConversationsArgs {
    /// The cursor for pagination
    pub cursor: Option<String>,
    /// The limit for pagination, default to 10
    pub limit: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct ListConversationsTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl ListConversationsTool {
    pub const NAME: &'static str = "list_prev_conversations";

    /// Creates a new ListConversationsTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<ListConversationsArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for ListConversationsTool {
    type Args = ListConversationsArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "List previous conversations".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let (chats, next_cursor) = self
            .memory
            .list_chats_by_user(ctx.caller(), args.cursor, args.limit)
            .await?;

        Ok(ToolOutput::new(Response::Ok {
            result: json!(chats),
            next_cursor,
        }))
    }
}

/// Arguments for "search_conversations" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct SearchConversationsArgs {
    /// The query string to search
    pub query: String,
    /// The max number of conversations to return, default to 10
    pub limit: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct SearchConversationsTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl SearchConversationsTool {
    pub const NAME: &'static str = "search_conversations";

    /// Creates a new SearchConversationsTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<SearchConversationsArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for SearchConversationsTool {
    type Args = SearchConversationsArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "Search conversations".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let chats = self
            .memory
            .search_chats(ctx.caller(), args.query, args.limit)
            .await?;

        Ok(ToolOutput::new(Response::Ok {
            result: json!(chats),
            next_cursor: None,
        }))
    }
}
