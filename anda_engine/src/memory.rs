use anda_cognitive_nexus::{CognitiveNexus, ConceptPK};
use anda_core::{
    BoxError, Document, Documents, FunctionDefinition, Resource, ResourceRef, StateFeatures, Tool,
    ToolOutput, Xid, gen_schema_for,
};
use anda_db::{
    collection::{Collection, CollectionConfig},
    database::AndaDB,
    error::DBError,
    index::BTree,
    query::{Filter, Query, RangeQuery, Search},
};
use anda_db_schema::{AndaDBSchema, FieldEntry, FieldType, Ft, Fv, Json, Schema, SchemaError};
use anda_db_tfs::jieba_tokenizer;
use anda_kip::{
    CommandType, DescribeTarget, KIP_FUNCTION_DEFINITION, KipError, META_SYSTEM_NAME, MetaCommand,
    PERSON_TYPE, Request, Response,
};
use candid::Principal;
use ciborium::cbor;
use ic_auth_types::ByteBufB64;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::{
    collections::BTreeMap,
    fmt,
    sync::{Arc, LazyLock},
};

use crate::{
    context::BaseCtx, extension::fetch::FetchWebResourcesTool, rfc3339_datetime,
    rfc3339_datetime_now, unix_ms,
};

pub static FUNCTION_DEFINITION: LazyLock<FunctionDefinition> =
    LazyLock::new(|| serde_json::from_value(KIP_FUNCTION_DEFINITION.clone()).unwrap());

#[derive(Debug, Clone, Deserialize, Serialize, AndaDBSchema)]
pub struct Conversation {
    /// The unique identifier for this resource in the Anda DB collection "conversation".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Option<Bytes>"]
    pub thread: Option<Xid>,

    pub messages: Vec<Json>,

    /// The request resources used by the agent to process the conversation.
    pub resources: Vec<Resource>,

    /// A collection of artifacts generated by the agent during the execution of the task.
    pub artifacts: Vec<Resource>,

    /// The state of the conversation.
    #[field_type = "Text"]
    pub status: ConversationStatus,

    /// The period when the conversation was created, in hours (timestamp / 3600 / 1000).
    /// It is used to index the conversation for faster retrieval by time.
    pub period: u64,

    /// The timestamp when the conversation was created, in milliseconds.
    pub created_at: u64,

    /// The timestamp when the conversation was updated, in milliseconds.
    pub updated_at: u64,
}

impl Conversation {
    pub fn to_changes(&self) -> Result<BTreeMap<String, Fv>, BoxError> {
        Ok(BTreeMap::from([
            (
                "messages".to_string(),
                Fv::array_from(cbor!(self.messages).unwrap(), &[Ft::Json])?,
            ),
            (
                "artifacts".to_string(),
                Fv::array_from(cbor!(self.artifacts).unwrap(), &[Resource::field_type()])?,
            ),
            ("status".to_string(), Fv::Text(self.status.to_string())),
            ("updated_at".to_string(), Fv::U64(self.updated_at)),
        ]))
    }
}

impl From<&Conversation> for Document {
    fn from(conversation: &Conversation) -> Self {
        let mut metadata = BTreeMap::from([
            ("_type".to_string(), "Conversation".into()),
            ("_id".to_string(), conversation._id.into()),
            ("user".to_string(), conversation.user.to_string().into()),
            ("status".to_string(), conversation.status.to_string().into()),
            (
                "created_at".to_string(),
                rfc3339_datetime(conversation.created_at).unwrap().into(),
            ),
            (
                "updated_at".to_string(),
                rfc3339_datetime(conversation.updated_at).unwrap().into(),
            ),
        ]);
        if let Some(thread) = &conversation.thread {
            metadata.insert("thread".to_string(), thread.to_string().into());
        }
        Self {
            content: json!(&conversation.messages),
            metadata,
        }
    }
}

#[derive(Debug, Serialize)]
pub struct ConversationRef<'a> {
    pub _id: u64,
    pub user: &'a Principal,
    pub thread: Option<&'a Xid>,
    pub messages: &'a [Json],
    pub resources: &'a [Resource],
    pub artifacts: &'a [Resource],
    pub status: &'a ConversationStatus,
    pub period: u64,
    pub created_at: u64,
    pub updated_at: u64,
}

impl<'a> From<&'a Conversation> for ConversationRef<'a> {
    fn from(conversation: &'a Conversation) -> Self {
        Self {
            _id: conversation._id,
            user: &conversation.user,
            thread: conversation.thread.as_ref(),
            messages: &conversation.messages,
            resources: &conversation.resources,
            artifacts: &conversation.artifacts,
            status: &conversation.status,
            period: conversation.period,
            created_at: conversation.created_at,
            updated_at: conversation.updated_at,
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct ConversationState {
    pub _id: u64,
    pub status: ConversationStatus,
}

impl From<&ConversationRef<'_>> for ConversationState {
    fn from(conversation: &ConversationRef<'_>) -> Self {
        Self {
            _id: conversation._id,
            status: conversation.status.clone(),
        }
    }
}

impl From<&Conversation> for ConversationState {
    fn from(conversation: &Conversation) -> Self {
        Self {
            _id: conversation._id,
            status: conversation.status.clone(),
        }
    }
}

#[derive(Debug, Clone, Deserialize, Serialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ConversationStatus {
    Submitted,
    Working,
    Completed,
    Canceled,
    Failed,
}

impl fmt::Display for ConversationStatus {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConversationStatus::Submitted => write!(f, "submitted"),
            ConversationStatus::Working => write!(f, "working"),
            ConversationStatus::Completed => write!(f, "completed"),
            ConversationStatus::Canceled => write!(f, "canceled"),
            ConversationStatus::Failed => write!(f, "failed"),
        }
    }
}

#[derive(Debug, Deserialize, Serialize, AndaDBSchema)]
pub struct KIPLogs {
    /// The unique identifier for this resource in the Anda DB collection "kip_logs".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Text"]
    pub command: CommandType,

    #[field_type = "Map<String, Json>"]
    pub request: anda_kip::Request,

    #[field_type = "Map<String, Json>"]
    pub response: anda_kip::Response,

    pub conversation: Option<u64>,

    pub period: u64,

    pub timestamp: u64,
}

#[derive(Debug, Clone)]
pub struct MemoryManagement {
    nexus: Arc<CognitiveNexus>,
    conversations: Arc<Collection>,
    logs: Arc<Collection>,
    resources: Arc<Collection>,
}

impl MemoryManagement {
    pub async fn connect(db: Arc<AndaDB>, nexus: Arc<CognitiveNexus>) -> Result<Self, BoxError> {
        let schema = Conversation::schema()?;
        let conversations = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "conversations".to_string(),
                    description: "conversations collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["user"]).await?;
                    collection.create_btree_index_nx(&["thread"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;
                    collection
                        .create_bm25_index_nx(&["messages", "resources", "artifacts"])
                        .await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        let schema = KIPLogs::schema()?;
        let logs = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "kip_logs".to_string(),
                    description: "KIP logs collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["user"]).await?;
                    collection.create_btree_index_nx(&["command"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        let schema = Resource::schema()?;
        let resources = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "resources".to_string(),
                    description: "Resources collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["tags"]).await?;
                    collection.create_btree_index_nx(&["hash"]).await?;
                    collection.create_btree_index_nx(&["mime_type"]).await?;
                    collection
                        .create_bm25_index_nx(&["name", "description", "metadata"])
                        .await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        Ok(Self {
            nexus,
            conversations,
            logs,
            resources,
        })
    }

    pub fn nexus(&self) -> Arc<CognitiveNexus> {
        self.nexus.clone()
    }

    pub async fn describe_primer(&self) -> Result<Json, KipError> {
        let (primer, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Primer))
            .await?;
        Ok(primer)
    }

    pub async fn describe_system(&self) -> Result<Json, KipError> {
        let system = self
            .nexus
            .get_concept(&ConceptPK::Object {
                r#type: PERSON_TYPE.to_string(),
                name: META_SYSTEM_NAME.to_string(),
            })
            .await?;
        let (domains, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Domains))
            .await?;
        Ok(json!({
            "identity": system.to_concept_node(),
            "domains": domains,
        }))
    }

    pub async fn add_resource(&self, resource: ResourceRef<'_>) -> Result<u64, DBError> {
        let id = self.resources.add_from(&resource).await?;
        self.resources.flush(unix_ms()).await?;
        Ok(id)
    }

    pub async fn try_add_resources(
        &self,
        resources: &[Resource],
    ) -> Result<Vec<Resource>, BoxError> {
        let mut rs: Vec<Resource> = Vec::with_capacity(resources.len());
        let mut count = 0;
        for r in resources.iter() {
            let rf: ResourceRef = r.into();
            let id = if r._id > 0 {
                r._id // TODO: check if the resource exists and has permission
            } else {
                match self.resources.add_from(&rf).await {
                    Ok(id) => {
                        count += 1;
                        id
                    }
                    Err(DBError::AlreadyExists { _id, .. }) => _id,
                    Err(err) => Err(err)?,
                }
            };

            let r2 = Resource {
                _id: id,
                blob: None,
                ..r.clone()
            };
            rs.push(r2)
        }

        if count > 0 {
            self.resources.flush(unix_ms()).await?;
        }

        Ok(rs)
    }

    pub async fn get_resource(&self, id: u64) -> Result<Resource, DBError> {
        self.resources.get_as(id).await
    }

    pub async fn add_conversation(
        &self,
        conversation: ConversationRef<'_>,
    ) -> Result<u64, DBError> {
        let id = self.conversations.add_from(&conversation).await?;
        self.conversations.flush(unix_ms()).await?;
        Ok(id)
    }

    pub async fn update_conversation(
        &self,
        id: u64,
        fields: BTreeMap<String, Fv>,
    ) -> Result<(), DBError> {
        self.conversations.update(id, fields).await?;
        self.conversations.flush(unix_ms()).await?;
        Ok(())
    }

    pub async fn get_conversation(&self, id: u64) -> Result<Conversation, DBError> {
        self.conversations.get_as(id).await
    }

    pub async fn list_conversations_by_user(
        &self,
        user: &Principal,
        cursor: Option<String>,
        limit: Option<usize>,
    ) -> Result<(Vec<Conversation>, Option<String>), BoxError> {
        let limit = limit.unwrap_or(10).min(100);
        let cursor = BTree::from_cursor::<u64>(&cursor)?;
        let filter = if let Some(cursor) = cursor {
            Some(Filter::And(vec![
                Box::new(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                Box::new(Filter::Field((
                    "_id".to_string(),
                    RangeQuery::Lt(Fv::U64(cursor)),
                ))),
            ]))
        } else {
            Some(Filter::Field((
                "user".to_string(),
                RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
            )))
        };

        let rt: Vec<Conversation> = self
            .conversations
            .search_as(Query {
                search: None,
                filter,
                limit: Some(limit),
            })
            .await?;
        let cursor = if rt.len() >= limit {
            BTree::to_cursor(&rt.first().unwrap()._id)
        } else {
            None
        };
        Ok((rt, cursor))
    }

    pub async fn search_conversations(
        &self,
        user: &Principal,
        query: String,
        limit: Option<usize>,
    ) -> Result<Vec<Conversation>, BoxError> {
        let rt = self
            .conversations
            .search_as(Query {
                search: Some(Search {
                    text: Some(query.to_string()),
                    logical_search: true,
                    ..Default::default()
                }),
                filter: Some(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                limit,
            })
            .await?;
        Ok(rt)
    }

    pub async fn list_kip_logs_by_user(
        &self,
        user: &Principal,
        cursor: Option<String>,
        limit: Option<usize>,
    ) -> Result<(Vec<KIPLogs>, Option<String>), BoxError> {
        let limit = limit.unwrap_or(10).min(100);
        let cursor = BTree::from_cursor::<u64>(&cursor)?;
        let filter = if let Some(cursor) = cursor {
            Some(Filter::And(vec![
                Box::new(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                Box::new(Filter::Field((
                    "_id".to_string(),
                    RangeQuery::Lt(Fv::U64(cursor)),
                ))),
            ]))
        } else {
            Some(Filter::Field((
                "user".to_string(),
                RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
            )))
        };

        let rt: Vec<KIPLogs> = self
            .logs
            .search_as(Query {
                search: None,
                filter,
                limit: Some(limit),
            })
            .await?;
        let cursor = if rt.len() >= limit {
            BTree::to_cursor(&rt.last().unwrap()._id)
        } else {
            None
        };
        Ok((rt, cursor))
    }

    pub async fn delete_expired_conversations(&self, timestamp: u64) -> Result<u64, BoxError> {
        let period = timestamp / 3600 / 1000;
        let filter = Filter::Field(("period".to_string(), RangeQuery::Lt(Fv::U64(period))));
        let ids = self
            .conversations
            .search_ids(Query {
                search: None,
                filter: Some(filter),
                limit: None,
            })
            .await?;
        let count = ids.len() as u64;
        for id in ids {
            if let Ok(Some(doc)) = self.conversations.remove(id).await
                && let Ok(conversation) = doc.try_into::<Conversation>()
            {
                for resource in conversation.resources {
                    if resource._id > 0 {
                        let _ = self.resources.remove(resource._id).await;
                    }
                }

                for artifact in conversation.artifacts {
                    if artifact._id > 0 {
                        let _ = self.resources.remove(artifact._id).await;
                    }
                }
            };
        }

        let now_ms = unix_ms();
        self.conversations.flush(now_ms).await?;
        self.resources.flush(now_ms).await?;
        Ok(count)
    }
}

/// KIP tool for memory management
impl Tool<BaseCtx> for Arc<MemoryManagement> {
    type Args = Request;
    type Output = Response;

    fn name(&self) -> String {
        FUNCTION_DEFINITION.name.clone()
    }

    fn description(&self) -> String {
        FUNCTION_DEFINITION.description.clone()
    }

    fn definition(&self) -> FunctionDefinition {
        FUNCTION_DEFINITION.clone()
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        request: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let timestamp = unix_ms();
        let conversation = ctx.get_state::<ConversationState>().map(|c| c._id);

        let (command, res) = request.execute(self.nexus.as_ref()).await;
        let log = KIPLogs {
            _id: 0, // This will be set by the database
            user: *ctx.caller(),
            command,
            request,
            response: res.clone(),
            conversation,
            period: timestamp / 3600 / 1000,
            timestamp,
        };

        self.logs.add_from(&log).await?;
        self.logs.flush(timestamp).await?;
        Ok(ToolOutput::new(res))
    }
}

/// Arguments for "get_resource_content" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct GetResourceContentArgs {
    /// The ID of the resource to get
    pub _id: u64,
}

#[derive(Debug, Clone)]
pub struct GetResourceContentTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl GetResourceContentTool {
    pub const NAME: &'static str = "get_resource_content";

    /// Creates a new GetResourceContentTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<GetResourceContentArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for GetResourceContentTool {
    type Args = GetResourceContentArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "Get a resource content as text (base64-url encoded if not UTF-8) by it's ID".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let res = self.memory.get_resource(args._id).await?;
        let text = match res.blob {
            Some(blob) => match String::from_utf8(blob.0) {
                Ok(s) => s,
                Err(e) => ByteBufB64(e.into_bytes()).to_string(),
            },
            None => match res.uri {
                Some(uri) => FetchWebResourcesTool::fetch_as_text(&ctx, &uri).await?,
                None => Err(format!("Invalid resource {}, no blob or uri", args._id))?,
            },
        };

        Ok(ToolOutput::new(Response::ok(text.into())))
    }
}

/// Arguments for "list_prev_conversations" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct ListConversationsArgs {
    /// The cursor for pagination
    pub cursor: Option<String>,
    /// The limit for pagination, default to 10
    pub limit: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct ListConversationsTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl ListConversationsTool {
    pub const NAME: &'static str = "list_prev_conversations";

    /// Creates a new ListConversationsTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<ListConversationsArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for ListConversationsTool {
    type Args = ListConversationsArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "List previous conversations".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let (conversations, next_cursor) = self
            .memory
            .list_conversations_by_user(ctx.caller(), args.cursor, args.limit)
            .await?;
        let docs: Vec<Document> = conversations.iter().map(Document::from).collect();
        let result = format!(
            "Current Datetime: {}\n---\n{}",
            rfc3339_datetime_now(),
            Documents::from(docs)
        );

        Ok(ToolOutput::new(Response::Ok {
            result: result.into(),
            next_cursor,
        }))
    }
}

/// Arguments for "search_conversations" tool
#[derive(Debug, Clone, Default, Deserialize, Serialize, JsonSchema)]
pub struct SearchConversationsArgs {
    /// The query string to search
    pub query: String,
    /// The max number of conversations to return, default to 10
    pub limit: Option<usize>,
}

#[derive(Debug, Clone)]
pub struct SearchConversationsTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl SearchConversationsTool {
    pub const NAME: &'static str = "search_conversations";

    /// Creates a new SearchConversationsTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<SearchConversationsArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for SearchConversationsTool {
    type Args = SearchConversationsArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "Search conversations".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let conversations = self
            .memory
            .search_conversations(ctx.caller(), args.query, args.limit)
            .await?;

        let docs: Vec<Document> = conversations.iter().map(Document::from).collect();
        let result = format!(
            "Current Datetime: {}\n---\n{}",
            rfc3339_datetime_now(),
            Documents::from(docs)
        );

        Ok(ToolOutput::new(Response::Ok {
            result: result.into(),
            next_cursor: None,
        }))
    }
}

/// Arguments for "memory_api" tool
#[derive(Debug, Clone, Deserialize, Serialize, JsonSchema, PartialEq, Eq)]
#[serde(tag = "_type")]
pub enum MemoryToolArgs {
    /// Get a conversation by ID
    GetConversation {
        /// The ID of the conversation to get
        _id: u64,
    },
    /// List previous conversations
    ListPrevConversations {
        /// The cursor for pagination
        cursor: Option<String>,
        /// The limit for pagination, default to 10
        limit: Option<usize>,
    },
    /// Search conversations
    SearchConversations {
        /// The query string to search
        query: String,
        /// The max number of conversations to return, default to 10
        limit: Option<usize>,
    },
    /// List KIP logs
    ListKipLogs {
        /// The cursor for pagination
        cursor: Option<String>,
        /// The limit for pagination, default to 10
        limit: Option<usize>,
    },
}

/// A tool for conversation API
#[derive(Debug, Clone)]
pub struct MemoryTool {
    memory: Arc<MemoryManagement>,
    schema: Json,
}

impl MemoryTool {
    pub const NAME: &'static str = "memory_api";

    /// Creates a new SearchConversationsTool instance
    pub fn new(memory: Arc<MemoryManagement>) -> Self {
        let schema = gen_schema_for::<MemoryToolArgs>();
        Self { memory, schema }
    }
}

impl Tool<BaseCtx> for MemoryTool {
    type Args = MemoryToolArgs;
    type Output = Response;

    fn name(&self) -> String {
        Self::NAME.to_string()
    }

    fn description(&self) -> String {
        "Conversation API".to_string()
    }

    fn definition(&self) -> FunctionDefinition {
        FunctionDefinition {
            name: self.name(),
            description: self.description(),
            parameters: self.schema.clone(),
            strict: Some(true),
        }
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        args: Self::Args,
        _resources: Vec<Resource>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        match args {
            MemoryToolArgs::GetConversation { _id } => {
                let conversation = self.memory.get_conversation(_id).await?;
                if &conversation.user != ctx.caller() {
                    return Err("permission denied".into());
                }

                Ok(ToolOutput::new(Response::Ok {
                    result: json!(conversation),
                    next_cursor: None,
                }))
            }
            MemoryToolArgs::ListPrevConversations { cursor, limit } => {
                let (conversations, next_cursor) = self
                    .memory
                    .list_conversations_by_user(ctx.caller(), cursor, limit)
                    .await?;

                Ok(ToolOutput::new(Response::Ok {
                    result: json!(conversations),
                    next_cursor,
                }))
            }
            MemoryToolArgs::SearchConversations { query, limit } => {
                let conversations = self
                    .memory
                    .search_conversations(ctx.caller(), query, limit)
                    .await?;

                Ok(ToolOutput::new(Response::Ok {
                    result: json!(conversations),
                    next_cursor: None,
                }))
            }
            MemoryToolArgs::ListKipLogs { cursor, limit } => {
                let (logs, next_cursor) = self
                    .memory
                    .list_kip_logs_by_user(ctx.caller(), cursor, limit)
                    .await?;

                Ok(ToolOutput::new(Response::Ok {
                    result: json!(logs),
                    next_cursor,
                }))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_conversation_status() {
        let chat = Conversation {
            _id: 0,
            user: Principal::anonymous(),
            thread: None,
            messages: Vec::new(),
            resources: Vec::new(),
            artifacts: Vec::new(),
            status: ConversationStatus::Completed,
            period: 0,
            created_at: 0,
            updated_at: 0,
        };
        let rt = ConversationStatus::Completed;
        println!("{}", rt);

        let rt = serde_json::to_string(&chat).unwrap();
        assert!(rt.contains(r#","status":"completed","#));
        let chat2: Conversation = serde_json::from_str(&rt).unwrap();
        assert_eq!(chat.status, chat2.status);

        let args = MemoryToolArgs::GetConversation { _id: 1 };
        let rt = serde_json::to_string(&args).unwrap();
        assert_eq!(rt, r#"{"_type":"GetConversation","_id":1}"#);
        let args1: MemoryToolArgs = serde_json::from_str(&rt).unwrap();
        assert_eq!(args, args1);
    }
}
