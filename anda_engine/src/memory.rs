use anda_cognitive_nexus::{CognitiveNexus, ConceptPK};
use anda_core::{BoxError, FunctionDefinition, Resource, StateFeatures, Tool, ToolOutput, Xid};
use anda_db::{
    collection::{Collection, CollectionConfig},
    database::AndaDB,
    error::DBError,
    index::BTree,
    query::{Filter, Query, RangeQuery},
};
use anda_db_schema::{AndaDBSchema, FieldEntry, FieldType, Fv, Json, Schema, SchemaError};
use anda_db_tfs::jieba_tokenizer;
use anda_kip::{
    CommandType, DescribeTarget, KIP_FUNCTION_DEFINITION, META_SYSTEM_NAME, MetaCommand,
    PERSON_TYPE, Request, Response,
};
use candid::Principal;
use serde::{Deserialize, Serialize};
use serde_json::json;
use std::sync::{Arc, LazyLock};

use crate::{context::BaseCtx, unix_ms};

pub static FUNCTION_DEFINITION: LazyLock<FunctionDefinition> =
    LazyLock::new(|| serde_json::from_value(KIP_FUNCTION_DEFINITION.clone()).unwrap());

#[derive(Debug, Clone, Deserialize, Serialize, AndaDBSchema)]
pub struct Chat {
    /// The unique identifier for this resource in the Anda DB collection "chat".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Option<Bytes>"]
    pub thread: Option<Xid>,

    pub messages: Vec<Json>,

    /// The request resources used by the agent to process the chat.
    pub resources: Option<Vec<Resource>>,

    /// A collection of artifacts generated by the agent during the execution of the task.
    pub artifacts: Option<Vec<Resource>>,

    /// The period when the chat was created, in hours (timestamp / 3600 / 1000).
    /// It is used to index the chat for faster retrieval by time.
    pub period: u64,

    /// The timestamp when the chat was created, in milliseconds.
    pub start_time: u64,

    /// The timestamp when the chat was ended, in milliseconds.
    pub end_time: u64,
}

#[derive(Debug, Serialize)]
pub struct ChatRef<'a> {
    /// The unique identifier for this resource in the Anda DB collection "chat".
    pub _id: u64,

    pub user: &'a Principal,

    pub thread: Option<&'a Xid>,

    pub messages: &'a [Json],

    /// The request resources used by the agent to process the chat.
    pub resources: Option<&'a [Resource]>,

    /// A collection of artifacts generated by the agent during the execution of the task.
    pub artifacts: Option<&'a [Resource]>,

    /// The period when the chat was created, in hours (timestamp / 3600 / 1000).
    /// It is used to index the chat for faster retrieval by time.
    pub period: u64,

    /// The timestamp when the chat was created, in milliseconds.
    pub start_time: u64,

    /// The timestamp when the chat was ended, in milliseconds.
    pub end_time: u64,
}

#[derive(Debug, Deserialize, Serialize, AndaDBSchema)]
pub struct KIPLogs {
    /// The unique identifier for this resource in the Anda DB collection "kip_logs".
    pub _id: u64,

    #[field_type = "Bytes"]
    pub user: Principal,

    #[field_type = "Text"]
    pub command: CommandType,

    #[field_type = "Map<String, Json>"]
    pub request: anda_kip::Request,

    #[field_type = "Map<String, Json>"]
    pub response: anda_kip::Response,

    pub period: u64,

    pub timestamp: u64,
}

#[derive(Clone)]
pub struct MemoryManagement {
    nexus: Arc<CognitiveNexus>,
    chats: Arc<Collection>,
    logs: Arc<Collection>,
}

impl MemoryManagement {
    pub async fn connect(nexus: Arc<CognitiveNexus>, db: Arc<AndaDB>) -> Result<Self, BoxError> {
        let schema = Chat::schema()?;
        let chats = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "chats".to_string(),
                    description: "chats collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["user"]).await?;
                    collection.create_btree_index_nx(&["thread"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;
                    collection
                        .create_bm25_index_nx(&[
                            "messages",
                            "request_resources",
                            "response_resources",
                        ])
                        .await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        let schema = KIPLogs::schema()?;
        let logs = db
            .open_or_create_collection(
                schema,
                CollectionConfig {
                    name: "kip_logs".to_string(),
                    description: "KIP logs collection".to_string(),
                },
                async |collection| {
                    // set tokenizer
                    collection.set_tokenizer(jieba_tokenizer());
                    // create BTree indexes if not exists
                    collection.create_btree_index_nx(&["command"]).await?;
                    collection.create_btree_index_nx(&["period"]).await?;

                    Ok::<(), DBError>(())
                },
            )
            .await?;

        Ok(Self { nexus, chats, logs })
    }

    pub async fn describe_primer(&self) -> Result<Json, BoxError> {
        let (primer, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Primer))
            .await?;
        Ok(primer)
    }

    pub async fn describe_system(&self) -> Result<Json, BoxError> {
        let system = self
            .nexus
            .get_concept(&ConceptPK::Object {
                r#type: PERSON_TYPE.to_string(),
                name: META_SYSTEM_NAME.to_string(),
            })
            .await?;
        let (domains, _) = self
            .nexus
            .execute_meta(MetaCommand::Describe(DescribeTarget::Domains))
            .await?;
        Ok(json!({
            "identity": system.to_concept_node(),
            "domains": domains,
        }))
    }

    pub async fn add_chat(&self, chat: &ChatRef<'_>) -> Result<(), BoxError> {
        let _ = self.chats.add_from(chat).await?;
        self.chats.flush(unix_ms()).await?;
        Ok(())
    }

    pub async fn list_chats_by_user(
        &self,
        user: &Principal,
        cursor: Option<String>,
        limit: Option<usize>,
    ) -> Result<Vec<Chat>, BoxError> {
        let cursor = BTree::from_cursor::<u64>(&cursor)?;
        let filter = if let Some(cursor) = cursor {
            Some(Filter::And(vec![
                Box::new(Filter::Field((
                    "user".to_string(),
                    RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
                ))),
                Box::new(Filter::Field((
                    "_id".to_string(),
                    RangeQuery::Lt(Fv::U64(cursor)),
                ))),
            ]))
        } else {
            Some(Filter::Field((
                "user".to_string(),
                RangeQuery::Eq(Fv::Bytes(user.as_slice().to_vec())),
            )))
        };

        let rt = self
            .chats
            .search_as(Query {
                search: None,
                filter,
                limit,
            })
            .await?;
        Ok(rt)
    }

    pub async fn delete_expired_chats(&self, timestamp: u64) -> Result<u64, BoxError> {
        let period = timestamp / 3600 / 1000;
        let filter = Filter::Field(("period".to_string(), RangeQuery::Lt(Fv::U64(period))));
        let ids = self
            .chats
            .search_ids(Query {
                search: None,
                filter: Some(filter),
                limit: None,
            })
            .await?;
        let count = ids.len() as u64;
        for id in ids {
            let _ = self.chats.remove(id).await;
        }

        self.chats.flush(unix_ms()).await?;
        Ok(count)
    }
}

impl Tool<BaseCtx> for Arc<MemoryManagement> {
    type Args = Request;
    type Output = Response;

    fn name(&self) -> String {
        FUNCTION_DEFINITION.name.clone()
    }

    fn description(&self) -> String {
        FUNCTION_DEFINITION.description.clone()
    }

    fn definition(&self) -> FunctionDefinition {
        FUNCTION_DEFINITION.clone()
    }

    async fn call(
        &self,
        ctx: BaseCtx,
        request: Self::Args,
        _resources: Option<Vec<Resource>>,
    ) -> Result<ToolOutput<Self::Output>, BoxError> {
        let timestamp = unix_ms();
        let (command, res) = request.execute(self.nexus.as_ref()).await;
        let log = KIPLogs {
            _id: 0, // This will be set by the database
            user: *ctx.caller(),
            command,
            request,
            response: res.clone(),
            period: timestamp / 3600 / 1000,
            timestamp,
        };

        // ignore errors from adding logs
        let _ = self.logs.add_from(&log).await;
        Ok(ToolOutput::new(res))
    }
}
